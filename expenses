#!/usr/bin/python
from datetime import date
import sys
import os
import subprocess
from collections import defaultdict
from mercurial import ui, hg, commands

VERSION="0.1"

HOME = os.getenv("HOME")
EXPENSES_DIR = os.path.join(HOME, ".expenses")
REPO_DIR = os.path.join(EXPENSES_DIR, 'repo')
EXPENSES_FILE=os.path.join(REPO_DIR, "expenses.csv")

EDITOR=os.getenv("EDITOR")
if not EDITOR:
    EDITOR = "vim"

cmds = {}
usages = {}

def cli(cmd, usage):
    """ Decorator for exposing a function to the command-line-interface.
    >>> @cli('add', 'add AMOUNT COMMENT')
    ... def add_fn(args):
    ...    pass
    >>> 'add' in cmds
    True
    >>> 'add' in usages:
    True
    """
    def deco(f):
        cmds[cmd] = f
        usages[cmd] = usage
        return f
    return deco

def commitafter(msg):
    """ Decorator for a function that modifies the expenses file. This
    causes it to commit a change to the repository if the function returns
    True, or to revert the change if it returns False """
    def deco(f):
        def _inner(*args, **kwargs):
            if f(*args, **kwargs):
                print "Commiting change"
                commands.commit(ui.ui(), repo, message=msg)
                return True
            else:
                print "Reverting change"
                # The date=False is for a bug in mercurial.
                commands.revert(ui.ui(), repo, all=True, date=False, no_backup=True)
                return False
        return _inner
    return deco



def print_usage():
    usage_strings = ["{0} {1}".format(sys.argv[0], usage) for k, usage in usages.iteritems()]
    print "USAGE: {0}".format(usage_strings[0])
    print "\n".join(["       {0}".format(s) for s in usage_strings[1:]])

class Entry(object):
    def __init__(self, s):
        d, amt, msg = s.split(',')
        self.date = date(*[int(n) for n in d.split("-")])
        self.amount = float(amt)
        self.message = msg
        
def parse_entries(f):
    try:
        return [Entry(line) for i, line in enumerate(f) if line.lstrip()[0] != "#"]
    except ValueError:
        print "Invalid expenses file, line:{0}".format(i+1)
        print line
        return None
        
#################################################
#  Command-line-interface function definitions  #
#################################################
@cli('add', 'add AMOUNT COMMENT')
@commitafter("Added expense")
def add(args):
    try:
        amt = float(args[0])
    except ValueError, e:
        print "Amount not recognized"
        print_usage()
        return False
    msg = args[1]
    with open(EXPENSES_FILE, 'a') as f:
        f.write("{0}, {1:.2f}, {2}\n".format(date.today().isoformat(), amt, msg))
    return True

@cli('list', 'list')
def fn_list(args):
    for line in open(EXPENSES_FILE):
        print line,
    return True

@cli('edit', 'edit')
@commitafter("Manually edited file")
def edit(args):
    rc = subprocess.call([EDITOR, EXPENSES_FILE])
    if rc != 0:
        print "Editing file failed"
        return False
    if parse_entries(open(EXPENSES_FILE)) is None:
        return False
    return True

@cli('summary', 'summary')
def summary(args):
    entries = parse_entries(open(EXPENSES_FILE))
    if entries is None:
        return False
    if len(entries) == 0:
        print "No data to summarize!"
        return True
    from_date = min(entry.date for entry in entries)
    to_date = max(entry.date for entry in entries)
    total_spent = sum(entry.amount for entry in entries)
    average_all = total_spent/((to_date-from_date).days + 1)
    spentdays = set(entry.date for entry in entries)
    # Average over days where some money was spent
    average_some = total_spent/len(spentdays)
    print "Report from {0} to {1}".format(from_date, to_date)
    print "Total spent: ${0:.2f}".format(total_spent)
    print "Average per day: ${0:.2f} (*30 = ${1:.2f})".format(average_all, average_all*30)
    print "Average per day on days with non-zero spending: ${0:.2f} (*30 = ${1:.2f})".format(average_some, average_some*30)
    return True
    

@cli('plot', 'plot')
def plot(args):
    import matplotlib.pyplot as plt
    import matplotlib.dates as mdates
    dayLocator = mdates.DayLocator()
    formatter = mdates.DateFormatter('%Y-%m-%d')
    dates = defaultdict(float)
    entries = parse_entries(open(EXPENSES_FILE))
    if entries is None:
        return False
    if len(entries) == 0:
        print "No entries to plot!"
        return True

    for entry in entries:
        dates[entry.date] += entry.amount

    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.bar([k for k in sorted(dates.keys())],
        [dates[k] for k in sorted(dates.keys())],
        color="#809860")
    ax.xaxis.set_major_locator(dayLocator)
    ax.xaxis.set_major_formatter(formatter)
    fig.autofmt_xdate()
    
    plt.show()
    return True
    #plt.plot((date(*k.split("-")) for k in sorted(dates.keys())),

######################################################################
# Initialization stuff                                               #
######################################################################
def init_dir():
    """Initialize the .expenses directory, and the mercurial repository"""
    try:
        os.mkdir(EXPENSES_DIR)
        os.mkdir(REPO_DIR)
    except OSError, e:
        print e
        return False
    with open(EXPENSES_FILE, 'w') as f:
        f.write("# Version: {0}\n".format(VERSION))
    repo = hg.repository(ui.ui(), REPO_DIR, create=True)
    commands.commit(ui.ui(), repo, EXPENSES_FILE, message="Initialized new expenses file", addremove=True)
    return True

def load_repo():
    """ Load the mercurial repository into the global repo variable """
    global repo
    repo = hg.repository(ui.ui(), REPO_DIR)

def main():
    # If the .expenses folder does not exist, create it.
    if not os.path.isdir(EXPENSES_DIR):
        if not init_dir(): return 1

    load_repo()

    if len(sys.argv) == 1:
        print_usage()
        return 1
    fn = cmds.get(sys.argv[1])
    if fn == None:
        print_usage()
        return 1
    if not fn(sys.argv[2:]):
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
